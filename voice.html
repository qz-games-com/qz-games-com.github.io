<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice Chat </title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      color: #ffffff;
      height: 100vh;
      overflow: hidden;
    }

    .login-container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    }

    .login-form {
      background: rgba(42, 42, 42, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 100%;
      max-width: 400px;
      transition: all 0.3s ease;
    }

    .login-form:hover {
      transform: translateY(-5px);
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
    }

    h1 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 2rem;
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .form-group {
      margin-bottom: 20px;
    }

    input {
      width: 100%;
      padding: 15px 20px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      color: #ffffff;
      font-size: 16px;
      transition: all 0.3s ease;
      outline: none;
    }

    input:focus {
      border-color: #667eea;
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.02);
    }

    input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .button-group {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
    }

    button {
      flex: 1;
      padding: 15px 20px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      outline: none;
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    .btn-primary {
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
    }

    .btn-secondary {
      background: linear-gradient(45deg, #56ab2f 0%, #a8e6cf 100%);
      color: white;
    }

    .btn-secondary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(86, 171, 47, 0.3);
    }

    .status {
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
    }

    .status.connected {
      background: rgba(86, 171, 47, 0.2);
      border-color: rgba(86, 171, 47, 0.3);
      color: #a8e6cf;
    }

    /* Call Interface */
    .call-container {
      display: none;
      height: 100vh;
      flex-direction: column;
      background: #2b2d31;
    }

    .call-header {
      background: rgba(42, 42, 42, 0.95);
      padding: 20px;
      text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .call-header h2 {
      font-size: 1.5rem;
      margin-bottom: 5px;
    }

    .call-status {
      color: #a8e6cf;
      font-size: 14px;
    }

    .call-main {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
    }

    .participants {
      display: flex;
      gap: 40px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    .participant {
      position: relative;
      text-align: center;
    }

    .participant-avatar {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      font-weight: bold;
      color: white;
      margin: 0 auto 15px;
      position: relative;
      transition: all 0.3s ease;
    }

    .participant-avatar.speaking {
      animation: speakingPulse 1s infinite;
    }

    @keyframes speakingPulse {
      0% { box-shadow: 0 0 0 0 rgba(131, 131, 131, 0.7); }
      70% { box-shadow: 0 0 0 20px rgba(102, 126, 234, 0); }
      100% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0); }
    }

    .participant-name {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .participant-status {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .video-container {
      position: relative;
      width: 300px;
      height: 200px;
      border-radius: 12px;
      overflow: hidden;
      background: #1a1a1a;
      margin: 0 auto 15px;
      z-index: 1;
    }

      .video-container video {
        position: relative;
        z-index: 2;
      }


    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .screen-share-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .screen-share-video {
      max-width: 90%;
      max-height: 90%;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .toolbar {
      background: rgba(42, 42, 42, 0.95);
      backdrop-filter: blur(10px);
      padding: 10px;
      width: fit-content;
      display: flex;
      justify-content: center;
      gap: 20px;
      border-radius: 15px;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
      position: absolute;
      box-shadow: 0px 0px 8px black;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .toolbar-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
    }

    .toolbar-btn:hover {
      transform: scale(1.1);
    }

    .toolbar-btn.mute {
      background: #777777;
    }

    .toolbar-btn.mute.muted {
      background: #c46565;
    }

    .toolbar-btn.video {
      background: #777777;
    }

    .toolbar-btn.video.video-off {
      background: #777777;
    }

    .toolbar-btn.screen-share {
      background: #667eea;
    }

    .toolbar-btn.screen-share.sharing {
      background: #646ec7;
      animation: pulse 2s infinite;
    }

    .toolbar-btn.hangup {
      background: #ff6b6b;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .screen-share-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      z-index: 20;
    }

    .audio-toggle {
      margin-left: 10px;
      padding: 5px 10px;
      background: #667eea;
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      font-size: 12px;
    }

/* Expanded/fullâ€‘window style for a <video> element */
  video.expanded {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  object-fit: contain;
  z-index: 9999;
  transition: all 0.3s ease-in-out;
  background: black;
}

/* When itâ€™s not expanded, restore its normal container constraints */
video:not(.expanded) {
  transition: all 0.3s ease-in-out;
}


    .pip-video {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 200px;
      height: 150px;
      border-radius: 8px;
      overflow: hidden;
      z-index: 15;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    @media (max-width: 768px) {
      .participants {
        flex-direction: column;
        gap: 20px;
      }
      
      .participant-avatar {
        width: 120px;
        height: 120px;
        font-size: 3rem;
      }
      
      .toolbar {
        gap: 15px;
        padding: 15px;
      }
      
      .toolbar-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="loginContainer" class="login-container">
    <div class="login-form">
      <h1>Voice Chat</h1>
      
      <div class="form-group">
        <input id="username" placeholder="Enter your username" maxlength="20" />
      </div>
      <div class="form-group">
        <input id="roomName" placeholder="Enter room name" maxlength="50" />
      </div>
      <div class="form-group">
        <input id="roomPass" type="password" placeholder="Enter password" maxlength="50" />
      </div>
      <div class="button-group">
        <button class="btn-primary" onclick="createRoom()">Create Room</button>
        <button class="btn-secondary" onclick="joinRoom()">Join Room</button>
      </div>
      
      <div id="status" class="status" style="display:none;"></div>
    </div>
  </div>

  <div id="callContainer" class="call-container">
    <div class="call-header">
      <h2 id="roomTitle">Room: Loading...</h2>
      <div class="call-status" id="callStatus">Connecting...</div>
    </div>
    
    <div class="call-main">
      <div class="participants" id="participants">
        <div class="participant" id="localParticipant">
          <div class="video-container">
            <video id="localVideo" muted autoplay playsinline></video>
          </div>
          <div class="participant-avatar" id="localAvatar">U</div>
          <div class="participant-name" id="localName">You</div>
          <div class="participant-status">Connected</div>
        </div>
        
        <div class="participant" id="remoteParticipant" style="display:none;">
          <div class="video-container">
            <video id="remoteVideo" autoplay playsinline></video>
          </div>
          <div class="participant-avatar" id="remoteAvatar">?</div>
          <div class="participant-name" id="remoteName">Waiting...</div>
          <div class="participant-status" id="otherstat">Connecting...</div>
        </div>
      </div>
      
      <div class="screen-share-container" id="screenShareContainer">
        <video id="screenShareVideo" class="screen-share-video" autoplay playsinline></video>
        <div class="screen-share-controls">
          <span>Screen sharing by <span id="sharerName">Unknown</span></span>
          <button class="audio-toggle" id="screenAudioToggle" onclick="toggleScreenAudio()" style="display:none;">
            ðŸ”Š Audio On
          </button>
        </div>
      </div>
    </div>
    
    <div class="toolbar">
      <button class="toolbar-btn mute" id="muteBtn" onclick="toggleMute()" title="Mute/Unmute">
        <span class="material-symbols" id="muteBtnn">
          mic
        </span>
      </button>
      <button class="toolbar-btn video" id="videoBtn" onclick="toggleVideo()" title="Camera On/Off">
        <span class="material-symbols" id="VideoBtnn">
          videocam
        </span>
      </button>
      <button class="toolbar-btn screen-share" id="screenBtn" onclick="toggleScreenShare()" title="Screen Share">
        <span class="material-symbols">
          desktop_windows
        </span>
      </button>
      <button class="toolbar-btn hangup" onclick="leaveCall()" title="Leave Call">
        <span class="material-symbols">
          call_end
        </span>
      </button>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
const firebaseConfig = {
  apiKey: "AIzaSyBaLTDvJY8ru-sjyfjcr4eTvZpUWp8uEYE",
  authDomain: "musicnow-abc0e.firebaseapp.com",
  databaseURL: "https://musicnow-abc0e-default-rtdb.firebaseio.com",
  projectId: "musicnow-abc0e",
  storageBucket: "musicnow-abc0e.firebasestorage.app",
  messagingSenderId: "432927188114",
  appId: "1:432927188114:web:428311a29b56fa972ff24b",
  measurementId: "G-RWBCBKWJ54"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

let localStream;
let screenStream;
let peerConnection;
let currentUser = null;
let remoteUser = null;
let currentRoom = null;
let roomRef = null;
let isMuted = false;
let isVideoOn = false;
let isScreenSharing = false;
let screenAudioEnabled = false;
let audioContext;
let localAudioAnalyser;
let remoteAudioAnalyser;
let isCaller = false;

// Minimal ICE configuration - just one STUN server
const servers = { 
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" }
  ]
};

function showStatus(message, isConnected = false) {
  const statusEl = document.getElementById("status");
  statusEl.textContent = message;
  statusEl.style.display = "block";
  statusEl.className = isConnected ? "status connected" : "status";
}

function getAvatarLetter(name) {
  return name ? name.charAt(0).toUpperCase() : '?';
}

function getRandomColor() {
  const colors = ['#667eea', '#764ba2', '#56ab2f', '#f093fb', '#ff6b6b', '#4ecdc4'];
  return colors[Math.floor(Math.random() * colors.length)];
}

function setupAudioAnalysis() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
  }

  if (localStream && localStream.getAudioTracks().length > 0) {
    try {
      const localSource = audioContext.createMediaStreamSource(localStream);
      localAudioAnalyser = audioContext.createAnalyser();
      localAudioAnalyser.fftSize = 256;
      localAudioAnalyser.smoothingTimeConstant = 0.3;
      localSource.connect(localAudioAnalyser);
      
      monitorAudio(localAudioAnalyser, 'localAvatar');
    } catch (error) {
      console.error("Error setting up audio analysis:", error);
    }
  }
}

function monitorAudio(analyser, avatarId) {
  const dataArray = new Uint8Array(analyser.frequencyBinCount);
  let speakingThreshold = 5;
  let consecutiveFrames = 0;
  
  function checkAudio() {
    if (analyser) {
      analyser.getByteFrequencyData(dataArray);
      const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
      
      const avatar = document.getElementById(avatarId);
      if (avatar) {
        if (average > speakingThreshold) {
          consecutiveFrames++;
          if (consecutiveFrames >= 3) {
            avatar.classList.add('speaking');
          }
        } else {
          consecutiveFrames = 0;
          avatar.classList.remove('speaking');
        }
      }
      
      requestAnimationFrame(checkAudio);
    }
  }
  
  checkAudio();
}

async function createRoom() {
  const username = document.getElementById("username").value.trim();
  const name = document.getElementById("roomName").value.trim();
  const pass = document.getElementById("roomPass").value.trim();
  
  if (!username || !name || !pass) {
    showStatus("Please fill in all fields");
    return;
  }

  showStatus("Creating room...");
  roomRef = db.ref("rooms/" + name);

  try {
    const snap = await roomRef.get();
    if (snap.exists()) {
      showStatus("Room already exists! Try joining instead.");
      return;
    }

    currentUser = { name: username, id: Date.now().toString() };
    
    await roomRef.remove();
    
    await roomRef.set({ 
      password: pass,
      created: Date.now(),
      users: 1,
      creator: currentUser,
      state: 'waiting'
    });

    currentRoom = name;
    isCaller = true;
    showStatus("Room created successfully!");
    await enterCall();
  } catch (error) {
    console.error("Error creating room:", error);
    showStatus("Error creating room: " + error.message);
  }
}

async function joinRoom() {
  const username = document.getElementById("username").value.trim();
  const name = document.getElementById("roomName").value.trim();
  const pass = document.getElementById("roomPass").value.trim();
  
  if (!username || !name || !pass) {
    showStatus("Please fill in all fields");
    return;
  }

  showStatus("Joining room...");
  roomRef = db.ref("rooms/" + name);

  try {
    const snap = await roomRef.get();
    if (!snap.exists()) {
      showStatus("Room doesn't exist. Create it first!");
      return;
    }
    
    const roomData = snap.val();
    if (roomData.password !== pass) {
      showStatus("Wrong password!");
      return;
    }

    if (roomData.users >= 2) {
      showStatus("Room is full! Maximum 2 users allowed.");
      return;
    }

    currentUser = { name: username, id: Date.now().toString() };
    await roomRef.child("users").set(2);
    await roomRef.child("joiner").set(currentUser);
    await roomRef.child("state").set('connecting');
    
    currentRoom = name;
    isCaller = false;
    showStatus("Joined room successfully!");
    await enterCall();
  } catch (error) {
    console.error("Error joining room:", error);
    showStatus("Error joining room: " + error.message);
  }
}

async function enterCall() {
  document.getElementById("loginContainer").style.display = "none";
  document.getElementById("callContainer").style.display = "flex";
  
  document.getElementById("roomTitle").textContent = `Room: ${currentRoom}`;
  document.getElementById("localName").textContent = currentUser.name;
  document.getElementById("localAvatar").textContent = getAvatarLetter(currentUser.name);
  document.getElementById("localAvatar").style.background = getRandomColor();
  
  await initializeMedia();
  setupUserMonitoring();
  
  setTimeout(async () => {
    await startCall();
  }, 500);
}

function setupUserMonitoring() {
  if (isCaller) {
    roomRef.child("joiner").on("value", snapshot => {
      const joiner = snapshot.val();
      if (joiner && joiner.id !== currentUser.id) {
        console.log("Joiner detected:", joiner);
        remoteUser = joiner;
        updateRemoteUser();
      }
    });
  } else {
    roomRef.child("creator").once("value", snapshot => {
      const creator = snapshot.val();
      if (creator) {
        console.log("Creator found:", creator);
        remoteUser = creator;
        updateRemoteUser();
      }
    });
  }
}

function updateRemoteUser() {
  if (remoteUser) {
    document.getElementById("remoteParticipant").style.display = "block";
    document.getElementById("remoteName").textContent = remoteUser.name;
    document.getElementById("remoteAvatar").textContent = getAvatarLetter(remoteUser.name);
    document.getElementById("remoteAvatar").style.background = getRandomColor();
  }
}

async function initializeMedia() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ 
      audio: { 
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 44100,
        channelCount: 1
      },
      video: false
    });

    document.getElementById("localVideo").srcObject = localStream;
    setupAudioAnalysis();
    console.log("Media initialized successfully");
  } catch (error) {
    console.error("Error accessing media:", error);
    showStatus("Error accessing microphone: " + error.message);
  }
}

async function startCall() {
  try {
    document.getElementById("callStatus").textContent = "Connecting...";
    
    peerConnection = new RTCPeerConnection(servers);
    
    // Simplified connection monitoring
    peerConnection.onconnectionstatechange = () => {
  console.log("Connection state:", peerConnection.connectionState);
  const statusEl = document.getElementById("callStatus");
  
      switch (peerConnection.connectionState) {
        case 'connected':
          document.getElementById("callStatus").textContent =  "Connected";
          document.getElementById("otherstat").textContent =  "Connected";
          break;
        case 'connecting':
          statusEl.textContent = "Connecting...";
          document.getElementById("otherstat").textContent =  "Connecting..";

          break;
        case 'disconnected':
        case 'failed':
          statusEl.textContent = "Disconnected";
          document.getElementById("otherstat").textContent =  "Disconnected";

          break;
      }

    };

    // Add local tracks (initially audio only)
    if (localStream) {
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });
    }

    // Handle remote tracks
    peerConnection.ontrack = event => {
      console.log("Received remote track:", event.track.kind);
      const remoteVideo = document.getElementById("remoteVideo");
      
      if (event.streams && event.streams[0]) {
        remoteVideo.srcObject = event.streams[0];
        
        // Setup remote audio analysis
        if (audioContext && event.streams[0].getAudioTracks().length > 0) {
          try {
            const remoteSource = audioContext.createMediaStreamSource(event.streams[0]);
            remoteAudioAnalyser = audioContext.createAnalyser();
            remoteAudioAnalyser.fftSize = 256;
            remoteAudioAnalyser.smoothingTimeConstant = 0.3;
            remoteSource.connect(remoteAudioAnalyser);
            monitorAudio(remoteAudioAnalyser, 'remoteAvatar');
          } catch (error) {
            console.error("Error setting up remote audio analysis:", error);
          }
        }
      }
    };

    // Simplified ICE candidate handling - send all candidates immediately
    peerConnection.onicecandidate = e => {
      console.log("onicecandidate fired:", e.candidate);
      if (e.candidate) {
        const path = isCaller ? "callerCandidates" : "calleeCandidates";
        console.log(`â†’ pushing candidate to /rooms/${currentRoom}/${path}`);
        roomRef.child(path).push({
          candidate: e.candidate.candidate,
          sdpMLineIndex: e.candidate.sdpMLineIndex,
          sdpMid: e.candidate.sdpMid
        });
      }
    };

    // Listen for remote ICE candidates
    const remotePath = isCaller ? "calleeCandidates" : "callerCandidates";
    const remoteCandidatesRef = roomRef.child(remotePath);
    remoteCandidatesRef.on("child_added", async snapshot => {
      const data = snapshot.val();
      console.log("â† got remote ICE candidate from", remotePath, ":", data);
      try {
        const candidate = new RTCIceCandidate(data);
        await peerConnection.addIceCandidate(candidate);
        console.log("âœ” added ICE candidate to RTCPeerConnection");
      } catch (error) {
        console.error("Error adding ICE candidate:", error);
      }
    });

    // RENEGOTIATION: listen for new offers/answers under /negotiation
    roomRef.child("negotiation/offers").on("child_added", async (snap) => {
      const offerData = snap.val();
      if (!offerData) return;

      // Only handle a new offer if weâ€™re currently stable (i.e. not in the middle of another negotiation)
      if (peerConnection.signalingState !== "stable") {
        console.log("â›” Ignoring renegotiation offer because not in stable:", peerConnection.signalingState);
        return;
      }

      console.log("â† got renegotiation offer:", offerData);
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData));
        // Create & send the matching answer
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        await roomRef.child("negotiation/answers").push({
          type: answer.type,
          sdp: answer.sdp
        });
        console.log("âœ” Published renegotiation answer");
      } catch (e) {
        console.error("Error handling renegotiation offer:", e);
      }
    });


    roomRef.child("negotiation/answers").on("child_added", async (snap) => {
      const answerData = snap.val();
      if (!answerData) return;

      // Only apply an incoming answer if we are in the middle of a local offer
      if (peerConnection.signalingState !== "have-local-offer") {
        console.log("â›” Ignoring renegotiation answer because not in have-local-offer:", peerConnection.signalingState);
        return;
      }

      console.log("â† got renegotiation answer:", answerData);
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answerData));
        console.log("âœ” Renegotiation answer applied");
      } catch (e) {
        console.error("Failed to set renegotiation answer:", e);
      }
    });


    // Start initial signaling (offer/answer)
    if (isCaller) {
      await handleCallerSignaling();
    } else {
      await handleJoinerSignaling();
    }
  } catch (error) {
    console.error("Error starting call:", error);
    document.getElementById("callStatus").textContent = "Connection failed";
  }
}

async function handleCallerSignaling() {
  try {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    await roomRef.child("offer").set({
      type: offer.type,
      sdp: offer.sdp
    });

    roomRef.child("answer").on("value", async snapshot => {
      const answerData = snapshot.val();
      if (answerData && !peerConnection.currentRemoteDescription) {
        console.log("â† got initial answer");
        const answer = new RTCSessionDescription(answerData);
        await peerConnection.setRemoteDescription(answer);
      }
    });
  } catch (error) {
    console.error("Error in caller signaling:", error);
  }
}

async function handleJoinerSignaling() {
  roomRef.child("offer").on("value", async snapshot => {
    const offerData = snapshot.val();
    if (offerData && !peerConnection.currentRemoteDescription) {
      try {
        console.log("â† got initial offer");
        const offer = new RTCSessionDescription(offerData);
        await peerConnection.setRemoteDescription(offer);
        
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        await roomRef.child("answer").set({
          type: answer.type,
          sdp: answer.sdp
        });
      } catch (error) {
        console.error("Error handling initial offer:", error);
      }
    }
  });
}

function toggleMute() {
  if (!localStream) return;
  
  isMuted = !isMuted;
  const audioTrack = localStream.getAudioTracks()[0];
  if (audioTrack) {
    audioTrack.enabled = !isMuted;
  }
  
  const muteBtn = document.getElementById("muteBtn");
  const muteBtnn = document.getElementById("muteBtnn");
  if (isMuted) {
    if (muteBtnn) muteBtnn.innerHTML = `mic_off`;
    if (muteBtn) muteBtn.classList.add("muted");
  } else {
    if (muteBtnn) muteBtnn.innerHTML = `mic`;
    if (muteBtn) muteBtn.classList.remove("muted");
  }
}

async function toggleVideo() {
  try {
    if (!isVideoOn) {
      // Turn video ON
      const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
      const videoTrack = videoStream.getVideoTracks()[0];
      
      localStream.addTrack(videoTrack);
      
      const videoSender = peerConnection.getSenders().find(s => 
        s.track && s.track.kind === 'video'
      );
      
      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
      } else {
        peerConnection.addTrack(videoTrack, localStream);
      }
      
      document.getElementById("localVideo").srcObject = localStream;
      document.getElementById("localVideo").style.display = "block";
      document.getElementById("localAvatar").style.display = "none";
      
      isVideoOn = true;
      document.getElementById("videoBtn").classList.remove("video-off");

      // RENEGOTIATE: send a new offer so the remote peer learns about this video track
      const renegRef = roomRef.child("negotiation");
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      await renegRef.child("offers").push({
        type: offer.type,
        sdp: offer.sdp
      });
      console.log("ðŸ”„ Sent renegotiation offer for video track");

    } else {
      // Turn video OFF
      const videoTrack = localStream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.stop();
        localStream.removeTrack(videoTrack);
        
        const videoSender = peerConnection.getSenders().find(s => 
          s.track && s.track.kind === 'video'
        );
        if (videoSender) {
          await videoSender.replaceTrack(null);
        }
      }
      
      document.getElementById("localVideo").style.display = "none";
      document.getElementById("localAvatar").style.display = "flex";
      
      isVideoOn = false;
      document.getElementById("videoBtn").classList.add("video-off");

      // RENEGOTIATE: inform remote peer that video track was removed
      const renegRef = roomRef.child("negotiation");
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      await renegRef.child("offers").push({
        type: offer.type,
        sdp: offer.sdp
      });
      console.log("ðŸ”„ Sent renegotiation offer (video removed)");
    }
    
    const videoBtnn = document.getElementById("videoBtnn");
    if (videoBtnn) {
      videoBtnn.innerHTML = isVideoOn ? "videocam" : "videocam_off";
    }
    
  } catch (error) {
    console.error("Error toggling video:", error);
    showStatus("Error accessing camera: " + error.message);
  }
}

async function toggleScreenShare() {
  try {
    if (!isScreenSharing) {
      // Start screen sharing
      screenStream = await navigator.mediaDevices.getDisplayMedia({ 
        video: { 
          cursor: "always",
          displaySurface: "monitor"
        }, 
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        }
      });
      
      const videoTrack = screenStream.getVideoTracks()[0];
      const audioTrack = screenStream.getAudioTracks()[0];
      
      // Replace video track for screen sharing
      const videoSender = peerConnection.getSenders().find(s => 
        s.track && s.track.kind === 'video'
      );
      
      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
      } else {
        peerConnection.addTrack(videoTrack, screenStream);
      }
      
      // Handle screen audio
      if (audioTrack) {
        screenAudioEnabled = true;
        audioTrack.enabled = screenAudioEnabled;
        peerConnection.addTrack(audioTrack, screenStream);
        
        const screenAudioToggle = document.getElementById("screenAudioToggle");
        if (screenAudioToggle) {
          screenAudioToggle.style.display = "inline-block";
          screenAudioToggle.textContent = "ðŸ”Š Screen Audio On";
        }
      }
      
      // Update UI
      const screenShareContainer = document.getElementById("screenShareContainer");
      const screenShareVideo = document.getElementById("screenShareVideo");
      const sharerName = document.getElementById("sharerName");
      
      if (screenShareContainer) screenShareContainer.style.display = "flex";
      if (screenShareVideo) screenShareVideo.srcObject = screenStream;
      if (sharerName) sharerName.textContent = currentUser.name;
      
      // Handle screen share end
      videoTrack.onended = () => {
        stopScreenShare();
      };
      
      isScreenSharing = true;
      document.getElementById("screenBtn").classList.add("sharing");

      // RENEGOTIATE: send a new offer so remote peer learns about screen share tracks
      const renegRef = roomRef.child("negotiation");
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      await renegRef.child("offers").push({
        type: offer.type,
        sdp: offer.sdp
      });
      console.log("ðŸ”„ Sent renegotiation offer for screen share");

    } else {
      await stopScreenShare();
    }
  } catch (error) {
    console.error("Error toggling screen share:", error);
    showStatus("Error starting screen share: " + error.message);
  }
}

async function stopScreenShare() {
  try {
    if (screenStream) {
      screenStream.getTracks().forEach(track => {
        track.stop();
      });
      
      const screenAudioTrack = screenStream.getAudioTracks()[0];
      if (screenAudioTrack) {
        const audioSender = peerConnection.getSenders().find(s => 
          s.track === screenAudioTrack
        );
        if (audioSender) {
          peerConnection.removeTrack(audioSender);
        }
      }
      
      const videoSender = peerConnection.getSenders().find(s => 
        s.track && s.track.kind === 'video'
      );
      
      if (videoSender) {
        if (isVideoOn && localStream.getVideoTracks().length > 0) {
          await videoSender.replaceTrack(localStream.getVideoTracks()[0]);
        } else {
          await videoSender.replaceTrack(null);
        }
      }
      
      screenStream = null;
    }
    
    const screenShareContainer = document.getElementById("screenShareContainer");
    const screenAudioToggle = document.getElementById("screenAudioToggle");
    
    if (screenShareContainer) screenShareContainer.style.display = "none";
    if (screenAudioToggle) screenAudioToggle.style.display = "none";
    
    isScreenSharing = false;
    screenAudioEnabled = false;
    document.getElementById("screenBtn").classList.remove("sharing");

    // RENEGOTIATE: inform remote peer that screen share tracks were removed
    const renegRef = roomRef.child("negotiation");
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    await renegRef.child("offers").push({
      type: offer.type,
      sdp: offer.sdp
    });
    console.log("ðŸ”„ Sent renegotiation offer (screen share removed)");

  } catch (error) {
    console.error("Error stopping screen share:", error);
  }
}

function toggleScreenAudio() {
  if (screenStream) {
    const audioTrack = screenStream.getAudioTracks()[0];
    if (audioTrack) {
      screenAudioEnabled = !screenAudioEnabled;
      audioTrack.enabled = screenAudioEnabled;
      
      const btn = document.getElementById("screenAudioToggle");
      if (btn) {
        btn.textContent = screenAudioEnabled ? "ðŸ”Š Screen Audio On" : "ðŸ”‡ Screen Audio Off";
      }
    }
  }
}

async function leaveCall() {
  try {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    if (screenStream) {
      screenStream.getTracks().forEach(track => track.stop());
    }

    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }

    if (roomRef) {
      roomRef.off();
    }

    if (currentRoom && roomRef) {
      const snap = await roomRef.get();
      
      if (snap.exists()) {
        const currentUsers = snap.val().users || 0;
        const newUserCount = Math.max(0, currentUsers - 1);
        
        if (newUserCount === 0) {
          await roomRef.remove();
        } else {
          await roomRef.child("users").set(newUserCount);
          if (snap.val().creator && snap.val().creator.id === currentUser.id) {
            await roomRef.child("creator").remove();
          } else if (snap.val().joiner && snap.val().joiner.id === currentUser.id) {
            await roomRef.child("joiner").remove();
          }
        }
      }
    }

    // Reset UI
    document.getElementById("callContainer").style.display = "none";
    document.getElementById("loginContainer").style.display = "flex";
    document.getElementById("remoteParticipant").style.display = "none";
    document.getElementById("screenShareContainer").style.display = "none";
    
    // Reset form
    document.getElementById("username").value = "";
    document.getElementById("roomName").value = "";
    document.getElementById("roomPass").value = "";
    
    // Reset variables
    currentRoom = null;
    currentUser = null;
    remoteUser = null;
    roomRef = null;
    isMuted = false;
    isVideoOn = false;
    isScreenSharing = false;
    screenAudioEnabled = false;
    isCaller = false;
    
    showStatus("Call ended successfully.");
    setTimeout(() => {
      const statusEl = document.getElementById("status");
      if (statusEl) statusEl.style.display = "none";
    }, 3000);

  } catch (error) {
    console.error("Error leaving call:", error);
  }
}

// Event listeners
window.addEventListener("beforeunload", () => {
  if (currentRoom) {
    leaveCall();
  }
});

document.addEventListener("keypress", (e) => {
  if (e.key === "Enter" && document.getElementById("loginContainer").style.display !== "none") {
    const username = document.getElementById("username").value.trim();
    const roomName = document.getElementById("roomName").value.trim();
    const roomPass = document.getElementById("roomPass").value.trim();
    
    if (username && roomName && roomPass) {
      createRoom();
    }
  }
});

document.addEventListener("keydown", (e) => {
  if (document.getElementById("callContainer").style.display !== "none") {
    switch(e.key.toLowerCase()) {
      case 'm':
        if (!e.ctrlKey && !e.altKey) {
          e.preventDefault();
          toggleMute();
        }
        break;
      case 'v':
        if (!e.ctrlKey && !e.altKey) {
          e.preventDefault();
          toggleVideo();
        }
        break;
      case 's':
        if (!e.ctrlKey && !e.altKey) {
          e.preventDefault();
          toggleScreenShare();
        }
        break;
    }
  }
});

// Initialize audio context on first user interaction
document.addEventListener('click', () => {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
  }
}, { once: true });

// Once the DOM is ready (you could put this at the end of your <script>)
  function enableVideoExpand() {
  // Select all video elements that should be clickable:
  const clickableVideos = [
    document.getElementById("localVideo"),
    document.getElementById("remoteVideo"),
    document.getElementById("screenShareVideo")
  ];

  clickableVideos.forEach(videoEl => {
    if (!videoEl) return;
    // On click, toggle the "expanded" class
    videoEl.style.cursor = "pointer";
    videoEl.addEventListener("click", () => {
      // If itâ€™s already expanded, shrink it; otherwise expand it
      if (videoEl.classList.contains("expanded")) {
        videoEl.classList.remove("expanded");
        if(videoEl.id === "localVideo") {
          document.getElementById('remoteVideo').parentElement.style.opacity = 1
        }
      } else {
        // Before expanding, remove â€œexpandedâ€ from any other video
        document.querySelectorAll("video.expanded").forEach(other => {
          if (other !== videoEl) other.classList.remove("expanded");
        });
        videoEl.classList.add("expanded");
        console.log('YAYA ' + videoEl.id)
        if(videoEl.id === "localVideo") {
          document.getElementById('remoteVideo').parentElement.style.opacity = 0
        }
      }
    });
  });
}

// Call this after your UI is in place:
document.addEventListener("DOMContentLoaded", () => {
  enableVideoExpand();
});


  </script>
</body>
</html>